import{_ as e,c as o,o as a,aS as r}from"./chunks/framework.TLL6yrB9.js";const b=JSON.parse('{"title":"js","description":"","frontmatter":{},"headers":[],"relativePath":"teach/index.md","filePath":"teach/index.md"}'),t={name:"teach/index.md"},c=r('<h1 id="js" tabindex="-1">js <a class="header-anchor" href="#js" aria-label="Permalink to &quot;js&quot;">​</a></h1><p>关于 js 的一些笔记</p><h2 id="柯里化" tabindex="-1">柯里化 <a class="header-anchor" href="#柯里化" aria-label="Permalink to &quot;柯里化&quot;">​</a></h2><h3 id="_1-什么是柯里化" tabindex="-1">1，什么是柯里化 <a class="header-anchor" href="#_1-什么是柯里化" aria-label="Permalink to &quot;1，什么是柯里化&quot;">​</a></h3><p>在一个函数中首先填充几个参数(然后再返回一个新函数)的技术称为柯里化(Currying)。 柯里化又称部分求值，字面意思就是不会立刻求值，而是到了需要的时候再去求值。 其含义是给函数分步传递参数，每次传递参数后部分应用参数，　　 并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。</p><h3 id="_2-js-柯里化的好处" tabindex="-1">2，js 柯里化的好处 <a class="header-anchor" href="#_2-js-柯里化的好处" aria-label="Permalink to &quot;2，js 柯里化的好处&quot;">​</a></h3><p>考虑到函数作用域的问题，在多层嵌套的函数式中，每一次都提取到每一层的函数式传参，剥离 this 指向，直接通过 fn()()()形式单一传参</p><h3 id="_3-柯里化-与-箭头函数" tabindex="-1">3， 柯里化 与 箭头函数 <a class="header-anchor" href="#_3-柯里化-与-箭头函数" aria-label="Permalink to &quot;3， 柯里化 与 箭头函数&quot;">​</a></h3><p>使用箭头函数之后，通常不需要再进行柯里化</p><p>箭头函数：‌ 箭头函数是 ES6 引入的一种新的函数语法，‌ 它允许你更简洁地编写函数，‌ 并且不会绑定自己的 this，‌ 使得在回调函数和事件处理器中使用更加方便。‌ 箭头函数本身并不直接涉及柯里化，‌ 但它为柯里化提供了基础。‌</p><p>高阶函数：‌ 高阶函数是指那些接受一个或多个函数作为参数，‌ 或者返回一个函数的函数。‌ 这种函数式编程的概念允许你以更灵活和模块化的方式组织代码。‌</p><p>柯里化：‌ 柯里化是一种将具有多个参数的函数转换成一系列使用一个参数的函数的技术。‌ 通过柯里化，‌ 你可以更好地控制函数的执行流程，‌ 尤其是在需要延迟计算或者分步骤传递参数的情况下。‌</p><h2 id="foreach-和-for-of" tabindex="-1">.forEach 和 for... of <a class="header-anchor" href="#foreach-和-for-of" aria-label="Permalink to &quot;.forEach 和 for... of&quot;">​</a></h2><ul><li><p>.forEach 方法</p><blockquote><p>.forEach 方法是一种直接遍历数组的方式。它接收一个回调函数，并对数组中的每个元素执行该函数</p></blockquote><p>const fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;];</p><p>fruits.forEach(fruit =&gt; { console.log(fruit); });</p></li><li><p>for...of 循环</p><blockquote><p>for...of 循环是在 ES6 中引入的，它提供了一种更灵活的方式来遍历可迭代对象（包括数组）</p></blockquote><p>const fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;];</p><p>for (const fruit of fruits) { console.log(fruit); }</p></li><li><p>for...of 的优势</p><blockquote><p>更好的异步处理 在处理异步操作时，for...of 显得尤为出色。.forEach 方法无法很好地与 async/await 配合使用，因为它无法原生处理 promise。 支持 break 和 continue 语句 for...of 更加强大和多功能，适用于复杂的迭代逻辑 提高可读性和可维护性 for...of 循环可以提高代码的可读性，特别是在处理嵌套结构或复杂操作时</p></blockquote></li><li><p>for...of 的高级技巧</p><blockquote><p>使用 Object.entries 遍历对象</p></blockquote><p>虽然 for...of 通常用于数组，但它也可以结合 Object.entries 方法来遍历对象：</p><p>const user = { name: &#39;Alice&#39;, age: 30, job: &#39;developer&#39; };</p><p>for (const [key, value] of Object.entries(user)) { console.log(<code>${key}: ${value}</code>); }</p><blockquote><p>使用生成器与 for...of 结合 生成器提供了一种创建自定义可迭代对象的强大方式。以下是如何将 for...of 与生成器函数结合使用：</p></blockquote><p>function* generateNumbers() { yield 1; yield 2; yield 3; }</p><p>for (const number of generateNumbers()) { console.log(number); }</p><blockquote><p>结合解构简化迭代逻辑 解构可以进一步简化你的迭代逻辑，使代码更加简洁：</p></blockquote><p>const users = [ { name: &#39;Alice&#39;, age: 30 }, { name: &#39;Bob&#39;, age: 25 } ];</p><p>for (const { name, age } of users) { console.log(<code>${name} is ${age} years old</code>); }</p></li></ul>',14),s=[c];function l(n,i,p,f,u,h){return a(),o("div",null,s)}const _=e(t,[["render",l]]);export{b as __pageData,_ as default};
